digraph "" {
ProxyFactory -> IProxyFactory [ label="1" ];
ProxyFactory -> ReentrancyGuard [ label="2" ];
ProxyFactory -> Initializable [ label="3" ];
ProxyFactory -> UUPSUpgradeable [ label="4" ];
ProxyFactory[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>ProxyFactory</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left"><font color="#FFA500">    createNewProxy(IStorageBeacon.AccountConfig)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    initialize(address)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    getOwner()</font></TD></TR><TR><TD align="left"><font color="#FFA500">    changeOwner(address)</font></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    _startTask(address)</TD></TR><TR><TD align="left">    _getStorageBeacon(uint256)</TD></TR><TR><TD align="left"><font color="#FFA500">    _authorizeUpgrade(address)</font></TD></TR><TR><TD align="left"><I>Modifiers:</I></TD></TR><TR><TD align="left">    onlyOwner()</TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left">    beacon</TD></TR></TABLE> >];

StorageBeacon -> IStorageBeacon [ label="1" ];
StorageBeacon -> Initializable [ label="2" ];
StorageBeacon -> Ownable [ label="3" ];
StorageBeacon[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>StorageBeacon</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left"><font color="#FFA500">    saveUserToDetails(address,IStorageBeacon.AccountConfig)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    saveTaskId(address,bytes32)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    changeGasPriceBid(uint256)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    addTokenToDatabase(address)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    removeTokenFromDatabase(address)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    storeBeacon(address)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    changeEmergencyMode(IStorageBeacon.EmergencyMode)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    changeEmitterStatus(bool)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    storeAccountPayment(address,uint256)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    addAuthorizedSelector(bytes4)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    isSelectorAuthorized(bytes4)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    getFixedConfig()</font></TD></TR><TR><TD align="left"><font color="#FFA500">    getGasPriceBid()</font></TD></TR><TR><TD align="left"><font color="#FFA500">    getEmergencyMode()</font></TD></TR><TR><TD align="left"><font color="#FFA500">    getAccountsByUser(address)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    getTaskID(address)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    getUserByAccount(address)</font></TD></TR><TR><TD align="left">    queryTokenDatabase(address)</TD></TR><TR><TD align="left"><font color="#FFA500">    isUser(address)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    getEmitterStatus()</font></TD></TR><TR><TD align="left"><font color="#FFA500">    getTokenDatabase()</font></TD></TR><TR><TD align="left"><font color="#FFA500">    getAccountPayments(address)</font></TD></TR><TR><TD align="left"><I>Modifiers:</I></TD></TR><TR><TD align="left">    hasRole(bytes4)</TD></TR><TR><TD align="left">    onlyAccount()</TD></TR><TR><TD align="left"><I>Public Variables:</I></TD></TR><TR><TD align="left">    accountToDetails</TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left">    fxConfig</TD></TR><TR><TD align="left">    eMode</TD></TR><TR><TD align="left">    taskIDs</TD></TR><TR><TD align="left">    tokenDatabase</TD></TR><TR><TD align="left">    userDatabase</TD></TR><TR><TD align="left">    userToAccounts</TD></TR><TR><TD align="left">    authorizedSelectors</TD></TR><TR><TD align="left">    accountToPayments</TD></TR><TR><TD align="left">    tokenDatabaseArray</TD></TR><TR><TD align="left">    gasPriceBid</TD></TR><TR><TD align="left">    beacon<font color="blue" POINT-SIZE="10"> (ozUpgradeableBeacon)</font></TD></TR><TR><TD align="left">    isEmitter</TD></TR></TABLE> >];

ozAccountProxy -> ReentrancyGuard [ label="1" ];
ozAccountProxy -> Initializable [ label="2" ];
ozAccountProxy -> BeaconProxy [ label="3" ];
ozAccountProxy[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>ozAccountProxy</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left"><font color="#FFA500">    receive()</font></TD></TR><TR><TD align="left">    checker()</TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    _getStorageBeacon()</TD></TR><TR><TD align="left"><font color="#FFA500">    _delegate(address)</font></TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left">    acc</TD></TR><TR><TD align="left">    fxConfig</TD></TR><TR><TD align="left">    beacon</TD></TR></TABLE> >];

ozUpgradeableBeacon -> ozIUpgradeableBeacon [ label="1" ];
ozUpgradeableBeacon -> UpgradeableBeacon [ label="2" ];
ozUpgradeableBeacon[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>ozUpgradeableBeacon</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left"><font color="#FFA500">    storageBeacon(uint256)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    upgradeStorageBeacon(address)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    setAuth(address)</font></TD></TR><TR><TD align="left"><font color="#FFA500">    canCall(address,address,bytes4)</font></TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left">    _storageBeacons</TD></TR><TR><TD align="left">    auth<font color="blue" POINT-SIZE="10"> (RolesAuthority)</font></TD></TR></TABLE> >];

IOps[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>IOps</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    createTaskNoPrepayment(address,bytes4,address,bytes,address)</TD></TR><TR><TD align="left">    getFeeDetails()</TD></TR><TR><TD align="left">    gelato()</TD></TR><TR><TD align="left">    getResolverHash(address,bytes)</TD></TR><TR><TD align="left">    exec(uint256,address,address,bool,bool,bytes32,address,bytes)</TD></TR><TR><TD align="left">    taskCreator(bytes32)</TD></TR></TABLE> >];

IProxyFactory[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>IProxyFactory</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    createNewProxy(IStorageBeacon.AccountConfig)</TD></TR><TR><TD align="left">    initialize(address)</TD></TR><TR><TD align="left">    getOwner()</TD></TR><TR><TD align="left">    changeOwner(address)</TD></TR></TABLE> >];

IStorageBeacon[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>IStorageBeacon</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    saveUserToDetails(address,IStorageBeacon.AccountConfig)</TD></TR><TR><TD align="left">    saveTaskId(address,bytes32)</TD></TR><TR><TD align="left">    changeGasPriceBid(uint256)</TD></TR><TR><TD align="left">    addTokenToDatabase(address)</TD></TR><TR><TD align="left">    removeTokenFromDatabase(address)</TD></TR><TR><TD align="left">    storeBeacon(address)</TD></TR><TR><TD align="left">    changeEmergencyMode(IStorageBeacon.EmergencyMode)</TD></TR><TR><TD align="left">    changeEmitterStatus(bool)</TD></TR><TR><TD align="left">    storeAccountPayment(address,uint256)</TD></TR><TR><TD align="left">    addAuthorizedSelector(bytes4)</TD></TR><TR><TD align="left">    isSelectorAuthorized(bytes4)</TD></TR><TR><TD align="left">    getFixedConfig()</TD></TR><TR><TD align="left">    getGasPriceBid()</TD></TR><TR><TD align="left">    getEmergencyMode()</TD></TR><TR><TD align="left">    getAccountsByUser(address)</TD></TR><TR><TD align="left">    getTaskID(address)</TD></TR><TR><TD align="left">    getUserByAccount(address)</TD></TR><TR><TD align="left">    isUser(address)</TD></TR><TR><TD align="left">    getEmitterStatus()</TD></TR><TR><TD align="left">    getTokenDatabase()</TD></TR><TR><TD align="left">    getAccountPayments(address)</TD></TR></TABLE> >];

ozIUpgradeableBeacon[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>ozIUpgradeableBeacon</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    storageBeacon(uint256)</TD></TR><TR><TD align="left">    upgradeStorageBeacon(address)</TD></TR><TR><TD align="left">    setAuth(address)</TD></TR><TR><TD align="left">    canCall(address,address,bytes4)</TD></TR></TABLE> >];

LibCommon[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>LibCommon</B></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    remove(address[],address)</TD></TR><TR><TD align="left">    remove(TradeOps[],TradeOps)</TD></TR></TABLE> >];

AggregatorV3Interface[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>AggregatorV3Interface</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    decimals()</TD></TR><TR><TD align="left">    description()</TD></TR><TR><TD align="left">    version()</TD></TR><TR><TD align="left">    getRoundData(uint80)</TD></TR><TR><TD align="left">    latestRoundData()</TD></TR></TABLE> >];

Ownable -> Context;
Ownable[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>Ownable</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    owner()</TD></TR><TR><TD align="left">    renounceOwnership()</TD></TR><TR><TD align="left">    transferOwnership(address)</TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    _transferOwnership(address)</TD></TR><TR><TD align="left"><I>Modifiers:</I></TD></TR><TR><TD align="left">    onlyOwner()</TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left">    _owner</TD></TR></TABLE> >];

IERC1822Proxiable[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>IERC1822Proxiable</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    proxiableUUID()</TD></TR></TABLE> >];

ERC1967Upgrade[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>ERC1967Upgrade</B></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    _getImplementation()</TD></TR><TR><TD align="left">    _setImplementation(address)</TD></TR><TR><TD align="left">    _upgradeTo(address)</TD></TR><TR><TD align="left">    _upgradeToAndCall(address,bytes,bool)</TD></TR><TR><TD align="left">    _upgradeToAndCallUUPS(address,bytes,bool)</TD></TR><TR><TD align="left">    _getAdmin()</TD></TR><TR><TD align="left">    _setAdmin(address)</TD></TR><TR><TD align="left">    _changeAdmin(address)</TD></TR><TR><TD align="left">    _getBeacon()</TD></TR><TR><TD align="left">    _setBeacon(address)</TD></TR><TR><TD align="left">    _upgradeBeaconToAndCall(address,bytes,bool)</TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left">    _ROLLBACK_SLOT</TD></TR><TR><TD align="left">    _IMPLEMENTATION_SLOT</TD></TR><TR><TD align="left">    _ADMIN_SLOT</TD></TR><TR><TD align="left">    _BEACON_SLOT</TD></TR></TABLE> >];

Proxy[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>Proxy</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    fallback()</TD></TR><TR><TD align="left">    receive()</TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    _delegate(address)</TD></TR><TR><TD align="left">    _implementation()</TD></TR><TR><TD align="left">    _fallback()</TD></TR><TR><TD align="left">    _beforeFallback()</TD></TR></TABLE> >];

BeaconProxy -> Proxy [ label="1" ];
BeaconProxy -> ERC1967Upgrade [ label="2" ];
BeaconProxy[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>BeaconProxy</B></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    _beacon()</TD></TR><TR><TD align="left"><font color="#FFA500">    _implementation()</font></TD></TR><TR><TD align="left">    _setBeacon(address,bytes)</TD></TR></TABLE> >];

IBeacon[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>IBeacon</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    implementation()</TD></TR></TABLE> >];

UpgradeableBeacon -> IBeacon [ label="1" ];
UpgradeableBeacon -> Ownable [ label="2" ];
UpgradeableBeacon[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>UpgradeableBeacon</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left"><font color="#FFA500">    implementation()</font></TD></TR><TR><TD align="left">    upgradeTo(address)</TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    _setImplementation(address)</TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left">    _implementation</TD></TR></TABLE> >];

Initializable[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>Initializable</B></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    _isConstructor()</TD></TR><TR><TD align="left"><I>Modifiers:</I></TD></TR><TR><TD align="left">    initializer()</TD></TR><TR><TD align="left">    onlyInitializing()</TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left">    _initialized</TD></TR><TR><TD align="left">    _initializing</TD></TR></TABLE> >];

UUPSUpgradeable -> IERC1822Proxiable [ label="1" ];
UUPSUpgradeable -> ERC1967Upgrade [ label="2" ];
UUPSUpgradeable[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>UUPSUpgradeable</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left"><font color="#FFA500">    proxiableUUID()</font></TD></TR><TR><TD align="left">    upgradeTo(address)</TD></TR><TR><TD align="left">    upgradeToAndCall(address,bytes)</TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    _authorizeUpgrade(address)</TD></TR><TR><TD align="left"><I>Modifiers:</I></TD></TR><TR><TD align="left">    onlyProxy()</TD></TR><TR><TD align="left">    notDelegated()</TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left">    __self</TD></TR></TABLE> >];

IERC20[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>IERC20</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    totalSupply()</TD></TR><TR><TD align="left">    balanceOf(address)</TD></TR><TR><TD align="left">    transfer(address,uint256)</TD></TR><TR><TD align="left">    allowance(address,address)</TD></TR><TR><TD align="left">    approve(address,uint256)</TD></TR><TR><TD align="left">    transferFrom(address,address,uint256)</TD></TR></TABLE> >];

Address[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>Address</B></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    isContract(address)</TD></TR><TR><TD align="left">    sendValue(address,uint256)</TD></TR><TR><TD align="left">    functionCall(address,bytes)</TD></TR><TR><TD align="left">    functionCall(address,bytes,string)</TD></TR><TR><TD align="left">    functionCallWithValue(address,bytes,uint256)</TD></TR><TR><TD align="left">    functionCallWithValue(address,bytes,uint256,string)</TD></TR><TR><TD align="left">    functionStaticCall(address,bytes)</TD></TR><TR><TD align="left">    functionStaticCall(address,bytes,string)</TD></TR><TR><TD align="left">    functionDelegateCall(address,bytes)</TD></TR><TR><TD align="left">    functionDelegateCall(address,bytes,string)</TD></TR><TR><TD align="left">    verifyCallResult(bool,bytes,string)</TD></TR></TABLE> >];

Context[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>Context</B></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    _msgSender()</TD></TR><TR><TD align="left">    _msgData()</TD></TR></TABLE> >];

StorageSlot[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>StorageSlot</B></TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    getAddressSlot(bytes32)</TD></TR><TR><TD align="left">    getBooleanSlot(bytes32)</TD></TR><TR><TD align="left">    getBytes32Slot(bytes32)</TD></TR><TR><TD align="left">    getUint256Slot(bytes32)</TD></TR></TABLE> >];

Auth[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>Auth</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    setAuthority(Authority)</TD></TR><TR><TD align="left">    setOwner(address)</TD></TR><TR><TD align="left"><I>Private Functions:</I></TD></TR><TR><TD align="left">    isAuthorized(address,bytes4)</TD></TR><TR><TD align="left"><I>Modifiers:</I></TD></TR><TR><TD align="left">    requiresAuth()</TD></TR><TR><TD align="left"><I>Public Variables:</I></TD></TR><TR><TD align="left">    owner</TD></TR><TR><TD align="left">    authority<font color="blue" POINT-SIZE="10"> (Authority)</font></TD></TR></TABLE> >];

Authority[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>Authority</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    canCall(address,address,bytes4)</TD></TR></TABLE> >];

RolesAuthority -> Auth [ label="1" ];
RolesAuthority -> Authority [ label="2" ];
RolesAuthority[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>RolesAuthority</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    doesUserHaveRole(address,uint8)</TD></TR><TR><TD align="left">    doesRoleHaveCapability(uint8,address,bytes4)</TD></TR><TR><TD align="left"><font color="#FFA500">    canCall(address,address,bytes4)</font></TD></TR><TR><TD align="left">    setPublicCapability(address,bytes4,bool)</TD></TR><TR><TD align="left">    setRoleCapability(uint8,address,bytes4,bool)</TD></TR><TR><TD align="left">    setUserRole(address,uint8,bool)</TD></TR><TR><TD align="left"><I>Public Variables:</I></TD></TR><TR><TD align="left">    getUserRoles</TD></TR><TR><TD align="left">    isCapabilityPublic</TD></TR><TR><TD align="left">    getRolesWithCapability</TD></TR></TABLE> >];

ReentrancyGuard[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>ReentrancyGuard</B></TD></TR><TR><TD align="left"><I>Modifiers:</I></TD></TR><TR><TD align="left">    nonReentrant()</TD></TR><TR><TD align="left"><I>Private Variables:</I></TD></TR><TR><TD align="left">    locked</TD></TR></TABLE> >];

IUniswapV3SwapCallback[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>IUniswapV3SwapCallback</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    uniswapV3SwapCallback(int256,int256,bytes)</TD></TR></TABLE> >];

ISwapRouter -> IUniswapV3SwapCallback;
ISwapRouter[shape="box"label=< <TABLE border="0"><TR><TD align="center"><B>ISwapRouter</B></TD></TR><TR><TD align="left"><I>Public Functions:</I></TD></TR><TR><TD align="left">    exactInputSingle(ISwapRouter.ExactInputSingleParams)</TD></TR><TR><TD align="left">    exactInput(ISwapRouter.ExactInputParams)</TD></TR><TR><TD align="left">    exactOutputSingle(ISwapRouter.ExactOutputSingleParams)</TD></TR><TR><TD align="left">    exactOutput(ISwapRouter.ExactOutputParams)</TD></TR></TABLE> >];

}